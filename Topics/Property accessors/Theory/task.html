<div class="step-text">
<p>As you already know, each class in Kotlin has zero or more <strong>properties</strong>. You will be using properties in almost all of your classes. In this topic, we will take a closer look at how to work with properties such as changing them and getting their values.</p>
<h5 id="property-getter">Property getter</h5>
<p>Suppose you have a simple class <code class="language-kotlin">Client</code> with one property <code class="language-kotlin">name</code>:</p>
<pre><code class="language-kotlin">class Client {
    val name = "Unknown"
}

val client = Client()</code></pre>
<p>You already know how to retrieve a property name: just type in the dot and the property name after the object name:</p>
<pre><code class="language-kotlin">client.name</code></pre>
<p>This looks very simple, but in fact, when you want to get the value of some property, you call a special <code class="language-kotlin">get()</code> function called <strong>getter</strong>. This is what it actually looks like:</p>
<pre><code class="language-kotlin">class Client {
    val name = "Unknown"
        get() {
            return field
        }
}

// or with omitted curly brackets and the body of the get() function

class Client {
    val name = "Unknown"
        get() = field
}</code></pre>
<p>This function takes nothing (you only ask a value, nothing more) and returns one value. When you try to retrieve a value, you will get the result of the <code class="language-kotlin">get()</code> function. So, what is <code class="language-kotlin">field</code>? Every property in Kotlin has its own <strong><a class="theory-lookup not-relevant" href="/learn/step/10511" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a backing field is a generated private property that stores the value of a property, allowing you to add more control over the property's behavior. | When you define a property in Kotlin, it automatically creates a backing field for it, which you can access using the `field` keyword in the property's getter or setter. By default, Kotlin generates a getter for you that simply returns the value of the backing field. However, you can provide a custom getter or setter to modify the behavior of the property.">backing field</a></strong>, which contains a property value that can be accessed with the <a class="theory-lookup not-relevant" href="/learn/step/10511" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a keyword is a word that has a special meaning in the language and cannot be changed by the programmer. | They are used to define the structure and behavior of the code. Examples of keywords in Kotlin include `fun` (used to define a function), `var` (used to define a variable), and `if` (used to define a conditional statement). Keywords are reserved words in Kotlin and cannot be used as identifiers. Identifiers, on the other hand, are names given to variables, functions, classes, or any other entity in the code. They are used to make the code more readable and understandable, and should be unique within their scope and follow the naming convention of Kotlin.">special keyword</a> <code class="language-kotlin">field</code>.</p>
<p>In this case, your getter just returns the value of the <code class="language-kotlin">name</code> variable. This is the <a class="theory-lookup not-relevant" href="/learn/step/10511" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, `expect` is a part of the language's experimental feature for coroutines, specifically for the `Flow` type. | It is used to define a flow that emits values asynchronously and can be collected by a collector. The `expect` function is designed for the common use case of state sharing, where it always carries an initial value, replaying the most recent value to new subscribers, and does not buffer additional values beyond the last emitted one. It behaves similarly to a `Channel` with specific parameters and when the `conflate` operator is applied. The `expect` function is recommended for use when you need a flow with modified behavior, such as extra buffering, replaying more values, or other specific requirements.">expected</a> behavior, so Kotlin generates this function for us, and you don't need to write it. If you want to change the logic of the getter, you should write your own <code class="language-kotlin">get()</code> function.</p>
<p>Sometimes you want to do something that does not fit into this implicit backing field scheme, you can always fall back to having a <strong><a class="theory-lookup not-relevant" href="/learn/step/10511" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a backing property is an additional feature of properties that allows you to customize the behavior of property accessors. | When you define a property, it automatically has a backing field generated by the compiler, which stores the value of the property. However, you can use a backing property to replace the backing field with custom getter and setter methods. This way, you can control how the property value is accessed and modified, providing an extra level of encapsulation and flexibility.">backing property</a></strong>. For example, we can use it to have a mutable value to save the info, and always return a read only val.</p>
<pre><code class="language-kotlin">class IntegerRepository {
    private val _list = mutableListOf&lt;Int&gt;()
    val list: List&lt;Int&gt; get() = _list // backing property
}

fun main() {
    val repository = IntegerRepository()
    repository.list.add(1) // Error: variable list is a read-only collection
    println(repository.list)
}</code></pre>
<h5 id="custom-getter">Custom getter</h5>
<p>Let's print the customer's name every time we access <code class="language-kotlin">name</code>:</p>
<pre><code class="language-kotlin">class Client {
    val name = "Unknown"
        get() {
            println("Somebody wants to know $field name")
            return field
        }
}

val client = Client()

val name = client.name // prints Somebody wants to know Unknown name
println(name)          // prints Unknown</code></pre>
<p>Another use for a <a class="theory-lookup not-relevant" href="/learn/step/10511" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a custom getter is a user-defined function that overrides the default getter function for a property. | By default, Kotlin generates a getter function for each property that returns the value of the property's backing field. However, if you want to customize the way the property's value is calculated or returned, you can define a custom getter function. Custom getters can be used to perform additional operations or calculations before returning the property's value. For example, you can use a custom getter to format a date or currency value, or to perform a complex calculation based on the property's value. Custom getters can also be used to control access to a property, such as by returning a default value or an error message when the property is accessed in an invalid way. Another use case for custom getters is when you want to return a different value than the one stored in the property's backing field. For instance, you can use a custom getter to return a subset of an array or a collection, or to combine the values of multiple properties into a single value.">custom getter</a> is if you want to return something else. For example, your task could be to store complete customer information in a variable. If you change some information about one person, you will have to change this variable as well. If you are using a custom getter, you can generate information on-demand. In the example below, the <code class="language-kotlin">Client</code> class gets an <code class="language-kotlin">age</code> property that stores the age of the client, and <code class="language-kotlin">info</code> property that returns the information about them:</p>
<pre><code class="language-kotlin">class Client {
    var name: String = "Unknown"
    var age: Int = 18
    val info: String
        get() {
            return "name = $name, age = $age"
        }
}

val client = Client()
println(client.info) // name = Unknown, age = 18
client.name = "Lester"
client.age = 20
println(client.info) // name = Lester, age = 20</code></pre>
<h5 id="property-setter">Property setter</h5>
<p>Now you know that you can customize the process of getting the property's value. It is also possible to modify the process of changing the property's value! Let's take a look at a simple example:</p>
<pre><code class="language-kotlin">class Client {
    var name = "Unknown" // default value
}

val client = Client()
client.name = "Ann"      // name property now stores "Ann"
</code></pre>
<p>When you want to set the value of some property, you should call a special <code class="language-kotlin">set()</code> function called <strong>setter</strong>. This is what it looks like:</p>
<pre><code class="language-kotlin">class Client {
    var name = "Unknown"
        set(value) {
            field = value
        }
}</code></pre>
<p>This function takes one argument (it is named <code class="language-kotlin">value</code> by convention, but you can use a different name) and returns nothing. As you know, <code class="language-kotlin">field</code> contains the current value of the property and you can change it by reassigning a different value.</p>
<p>In this case, your setter will simply change the value of the <code class="language-kotlin">name</code> variable to the received value. This is the expected behavior and Kotlin generates this function for us, you don't need to write the setter yourself.</p>
<h5 id="custom-setter">Custom setter</h5>
<p>The <code class="language-kotlin">set()</code> function is a powerful instrument and it's possible to customize the logic of a setter. For example, let's print the customer's name every time we change the <code class="language-kotlin">name</code> property:</p>
<pre><code class="language-kotlin">class Client {
    var name = "Unknown"
        set(value) {
            println("The name is changing. Old value is $field. New value is $value.")
            field = value
        }
}

val client = Client()
client.name = "Ann"   // The name is changing. Old value is Unknown. New value is Ann.</code></pre>
<p>As you may notice, the setter is only called when you're trying to change the property, not when initializing it.</p>
<p>Another way to use a <a class="theory-lookup not-relevant" href="/learn/step/10511" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a custom setter is an additional feature that allows you to customize the behavior of a property setter. | By default, a setter changes the value of the property to the received value. However, you can modify this behavior to suit your needs. For instance, you can print a message every time the property value is changed, or assign a different value based on certain conditions. A common use case for custom setters is to ensure that a property, such as the age of a client, cannot be set to a negative value.">custom setter</a> is if you wanted to assign a different value. Let's add an <code class="language-kotlin">age</code> property that stores the age of the client. Of course, age cannot be negative. If you want to take it into account, you can add a custom setter:</p>
<pre><code class="language-kotlin">class Client {
    var name = "Unknown"
    var age = 18
        set(value) {                      
            field = if (value &lt; 0) {
                println("Age cannot be negative. Set to $defaultAge")
                defaultAge
            } else
                value
        }
    val defaultAge = 18
}

val client = Client()
client.age = -1      // Age cannot be negative. Set to 18.
println(client.age)  // 18</code></pre>
<h5 id="additional-features">Additional features</h5>
<p>You may implement both a setter and a getter for your property:</p>
<pre><code class="language-kotlin">class Client {
    var name = "Unknown"
        get() {
            println("Somebody wants to know $field name")
            return field
        }
        set(value) {
            println("The name is changing. Old value is $field. New value is $value.")
            field = value
        }
}</code></pre>
<p>If you want to add a getter and/or a setter to a property in a constructor, just "move" the property out. Remember that in this case, you need to use another variable, not the property from the constructor:</p>
<pre><code class="language-kotlin">class Client(name: String, age: Int) {
    var fullName: String = name
        set(value) {
            println("The name is changing. Old value is $field. New value is $value.")
            field = value
        }
    var age: Int = age   // this is a new property, not a property from the constructor
        set(value) {
            println("The age is changing. Old value is $field. New value is $value.")
            field = value
        }
}</code></pre>
<p>Keep in mind that when initializing your property, the setter will not be called. This is also true for constructors since they initialize properties. Let's take a closer look:</p>
<pre><code class="language-kotlin">class Client(name: String) {
    var name: String = name
        set(value) {
            println("The name is changing. Old value is $field. New value is $value.")
            field = value
        }
}

val client = Client("Annie")  // without output
client.name = "Ann"           // The name is changing. Old value is Annie. New value is Ann.</code></pre>
<p>You cannot use a setter for <code class="language-kotlin">val</code> variables: the <code class="language-kotlin">set()</code> function reassigns the variable, which is not possible for <code class="language-kotlin">val</code>. Of course, you can change the internal state of the <code class="language-kotlin">val</code> property another way, for example, with its own setters.</p>
<pre><code class="language-kotlin">class Passport(number: String) {
    var number = number
    set(value) {
        println("Passport number has changed.")
        field = value
    }
}

class Client {
    val passport = Passport("1234567")
}

val client = Client()
println(client.passport.number)       // 1234567
/*
client.passport = Passport("2345678") // This will not work.
*/
client.passport.number = "2345678"    // This will change the passport number
                                      // prints Passport number has changed
println(client.passport.number)       // 2345678</code></pre>
<h5 id="conclusion">Conclusion</h5>
<p>Kotlin properties are a really pragmatic way to work with <a class="theory-lookup not-relevant" href="/learn/step/10511" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a class field is a variable or property declared inside a class that stores a value. | Fields can be of various types, such as numbers, strings, or other objects, and they can be accessed and modified within the class they are declared in. The visibility of fields can be controlled using access modifiers such as `private`, `protected`, or `public`. To allow access to a private field from outside the class, getter and setter methods can be used. Fields can also be initialized through a constructor and can have visibility modifiers specified for them.">class fields</a>. Now you know about the default getter and setter methods and their customization. It is a really powerful tool that will help you in a lot of situations like logging and handling input.</p>
</div>