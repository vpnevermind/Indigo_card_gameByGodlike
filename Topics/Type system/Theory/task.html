<div class="step-text">
<p>One of the most important parts of Kotlin is the <a class="theory-lookup not-relevant" href="/learn/step/9689" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a type system is a set of rules that define the allowed types of data and operations that can be performed on them. | It is a crucial concept in statically typed languages like Kotlin, where type relationships are checked at compile time. A type defines a set of valid values within a domain and a set of appropriate and consistent operations for the established value domain. In a hierarchical relationship, a subtype is a type that is related to another type (the supertype), inheriting all its characteristics (valid values and operations), but it may also have additional values or operations or restrict the value in some way.">type system</a>, a mechanism for detecting and preventing illegal program states. It imposes structure on our program. Without structure, programs are wildly complex, ready to "do damage" at the slightest mistake of the programmer. With the help of types, we can describe and give meaning to the relationships between components in our program, making it concise and readable.</p>
<h5 id="subtype-and-supertype">Subtype and supertype</h5>
<p>Types in Kotlin are organized into a hierarchy of subtype-supertype relationships. So what are the subtype and supertype? Let's find it out by looking at an example.</p>
<p>Do you like coffee or tea? Well, both are drinks. We can state the fact that coffee and tea are related to a specific type: drinks. In other words, coffee and tea are <strong>subtypes</strong> of drink, while drink is the <strong>supertype</strong> for these two types:</p>
<p style="text-align: center;"><picture><img alt="certain types and subtypes" height="272" src="https://ucarecdn.com/41c926d0-f108-40d0-9ee7-73eced7c11de/" width="339"/></picture></p>
<p>So, the <strong>subtype</strong><em> </em>is a datatype that is related to another datatype (<em>supertype</em>) and shares common characteristics and rules of behavior with it. Note that the rules of behavior of different <em>subtypes </em>may vary, just like all kinds of drinks have some sort of color, but it's different for coffee and tea.</p>
<p>Logically, <strong>supertype</strong> is a type that specifies the characteristics and rules of behavior that every subtype<em> </em>will follow.</p>
<p>For example, <code class="language-kotlin">Number</code> is a supertype<em> </em>for all types that represent numeric value; <code class="language-kotlin">Int</code> and <code class="language-kotlin">Double</code> are subtypes<em> </em>of <code class="language-kotlin">Number</code> type.</p>
<p style="text-align: center;"><picture><img alt="example of types and subtypes" height="290" src="https://ucarecdn.com/2347dcf1-ea0f-44bb-bfe8-8665aee5f5c1/" width="354"/></picture></p>
<h5 id="type-checking">Type checking</h5>
<p>Kotlin type checker enforces subtype-supertype relationships. For example, to the function that's waiting for <code class="language-kotlin">Number</code><em>,</em> you can pass its subtype, <code class="language-kotlin">Int</code>:</p>
<pre><code class="language-kotlin">fun calculate(number: Number) {}

val number: Int = 1
calculate(number)</code></pre>
<p>However, you cannot do it the other way around:</p>
<pre><code class="language-kotlin">fun calculate(number: Int) {}

val number: Number = 1
calculate(number) // Error: Type mismatch: inferred type is Number but Int was expected </code></pre>
<p>If you pass a <code class="language-kotlin">Number</code> to the <code class="language-kotlin">calculate</code> function, you will get an error. Now let's see what type is a <strong>supertype</strong> for <code class="language-kotlin">Number</code>, <code class="language-kotlin">Drink</code>, and other types that can't be <code class="language-kotlin">null</code>.</p>
<h5 id="root-type-any">Root type <em>Any</em></h5>
<p>In the previous topics, you got familiar with the concept of nullable and non-<a class="theory-lookup not-relevant" href="/learn/step/9689" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a nullable type is a variable that can hold a null value, in contrast to a non-nullable type, which cannot. | This is a key feature of Kotlin's null safety, which aims to eliminate null reference errors. In Kotlin, types are non-nullable by default, and if you want to declare a variable that can hold a null value, you must append a question mark to the type. When working with nullable types, Kotlin requires you to handle the possibility of a null value explicitly, making your code safer and more predictable.">nullable types</a>. Now it's time to look deeper and understand what represents these types in Kotlin. </p>
<p>In Kotlin, type <code class="language-kotlin">Any</code> is a supertype<strong> </strong>for all types that don't support null. This means that any <a class="theory-lookup not-relevant" href="/learn/step/9689" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a non-nullable is a type that cannot hold a null value. | Unlike Java, where all reference types can hold null values, Kotlin makes a distinction between nullable and non-nullable types. By making types non-nullable by default and providing explicit nullable types, Kotlin compels developers to handle the possibility of null values in a controlled way. This helps to reduce the risk associated with null references, often referred to as the billion-dollar mistake. Safe call and the elvis operator are two features in Kotlin that help handle nullable types securely and prevent null pointer exceptions. Safe call allows you to access properties and methods of a nullable object without the risk of a null pointer exception.">non-nullable</a> type is a subtype<em> </em>of <code class="language-kotlin">Any</code><em>. </em>For example, you can assign non-null <code class="language-kotlin">String</code> to <code class="language-kotlin">Any</code><em> </em>type:</p>
<pre><code class="language-kotlin">val message: Any = "Important message"</code></pre>
<p>However, you cannot assign a null value to the <code class="language-kotlin">Any</code><em> </em>type:</p>
<pre><code class="language-kotlin">val message: Any = null  // Error: Null can not be a value of a non-null type Any</code></pre>
<p>Type <code class="language-kotlin">Any</code><strong> </strong>is also a supertype for primitives such as <code class="language-kotlin">Boolean</code>:</p>
<pre><code class="language-kotlin">val isNull: Any = false</code></pre>
<p>Type <em>Any</em> is at the top of the Kotlin type hierarchy for types that cannot be null. For example, the type <code class="language-kotlin">Number</code> is a subtype<em> </em>of type <em>Any</em>:</p>
<p style="text-align: center;"><picture><img alt="Type Any is at the top of the Kotlin type hierarchy for types that cannot be null" height="289" src="https://ucarecdn.com/4dd59f84-7aa1-4c41-825d-b326a7c0aa7c/" width="161"/></picture></p>
<p>Note that type <code class="language-kotlin">Any</code><em> </em>does not support <code class="language-kotlin">null</code>. When we talk about a type as a subtype of <code class="language-kotlin">Any</code>, we can be sure that when we try to access this type, we will not get a <code class="language-kotlin">NullPointerException</code>. In other words, Kotlin guarantees that the subtype of type <code class="language-kotlin">Any</code> can never be <code class="language-kotlin">null</code>, which means that <code class="language-kotlin">null</code> checks become useless when we're dealing with type <code class="language-kotlin">Any</code>:</p>
<pre><code class="language-kotlin">fun stringify(any: Any) {
    any?.toString()  // '?' can be omitted
    any!!.toString() // '!!' can be omitted
}</code></pre>
<h5 id="root-type-any">Root type <em>Any?</em></h5>
<p>As you know, the suffix '?' is used when declaring a variable that can be null. Note that you can't assign null to non-null variables. Let's see an example:</p>
<pre><code class="language-kotlin">val number1: Number = null // Error: Null can not be a value of a non-null type Number</code></pre>
<pre><code class="language-kotlin">val number2: Number? = null // OK</code></pre>
<p>While type <code class="language-kotlin">Any</code><strong> </strong>is a supertype for all types that do not support null, <code class="language-kotlin">Any?</code> is a supertype for types that can be either null or not.<br/>From this fact, it follows that type <code class="language-kotlin">Any?</code> is a supertype for type <code class="language-kotlin">Any</code>:</p>
<p style="text-align: center;"><picture><img alt="тип Any является супертипом для типа Any" height="294" src="https://ucarecdn.com/841f6033-0d40-4ce9-85d0-301f4c4ca66e/" width="164"/></picture></p>
<p>Non-null type is a subtype of its nullable equivalents, for example, type <code class="language-kotlin">Number</code> is a subtype of type<em> </em><code class="language-kotlin">Number?</code>, and type<em> </em><code class="language-kotlin">Int</code> is a subtype of type <code class="language-kotlin">Int?</code>. Let's see what it looks like:</p>
<p style="text-align: center;"><picture><img alt="example of type and subtype hierarchy" height="405" src="https://ucarecdn.com/81310c7f-1f48-4048-a5e8-bf2e50a57600/" width="386"/></picture></p>
<p>This is why you can store a non-null <code class="language-kotlin">Number</code> value in a nullable <code class="language-kotlin">Number?</code> variable,  but you cannot store a nullable <code class="language-kotlin">Number?</code> value in a non-null <code class="language-kotlin">Number</code> variable.</p>
<h5 id="unit">Unit</h5>
<p><code class="language-kotlin">Unit</code> type can be used as the return type of a function that does not return any meaningful value:</p>
<pre><code class="language-kotlin">fun logCurrentState(): Unit { 
    println("Current state of a program: $state")
}</code></pre>
<p>If you write a function and the return type is not specified, the compiler will treat it as a <code class="language-kotlin">Unit</code> function:</p>
<pre><code class="language-kotlin">fun updateState(state: State) { 
    logCurrentState()
    this.state = state
    logCurrentState()
}

val result: Unit = logCurrentState()</code></pre>
<p>Like any other type, <code class="language-kotlin">Unit</code> is a subtype of <code class="language-kotlin">Any</code>. It can also be a nullable <code class="language-kotlin">Unit?</code>, which is a subtype of<em> </em><code class="language-kotlin">Any?</code>.</p>
<p><code class="language-kotlin">Unit?</code> is a type that can be two values: the <code class="language-kotlin">Unit</code> value and <code class="language-kotlin">null</code>.</p>
<p style="text-align: center;"><picture><img alt="Any and Unit type hierarchy" height="286" src="https://ucarecdn.com/cb5017d1-be80-4e66-a98b-20ddf0b3a52b/" width="429"/></picture></p>
<h5 id="nothing">Nothing</h5>
<p>At the very bottom of the Kotlin type hierarchy is the type <code class="language-kotlin">Nothing</code>.</p>
<p><code class="language-kotlin">Nothing</code> is a type that has no <a class="theory-lookup not-relevant" href="/learn/step/9689" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, an instance refers to an object or an instance of a class that is created during runtime. | It is a subtype of every known type in Kotlin, meaning it can represent a value of any type in terms of type checking. This is particularly useful in situations where a function demands a return type, but it is impossible to return a value, such as when calculating a percentage if the value is zero. In such cases, a function that returns `Instance` can be used. The concept of instance is also related to threading, where only one thread can execute code in a synchronized method of a particular instance. This means that different threads can execute methods of different objects at the same time, a concept that can be summarized as one thread per instance.">instances</a>. For some functions in Kotlin, the concept of a <a class="theory-lookup not-relevant" href="/learn/step/9689" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a return value is the result produced by a function after it has completed its execution. | It is determined by the last expression in the function's body, which must be an expression-style statement. If a function has a specified return type, it indicates that the function will not return a value under any circumstance, such as when it throws an exception or enters an infinite loop. Understanding return values is important for writing clean, readable, and robust code in Kotlin.">return value</a> doesn't make sense, as they never return values and always throw an exception. We'll look at <a class="theory-lookup not-relevant" href="/learn/step/9689" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, nothing is a concept related to functions that do not return any value or perform any action. | It is often implied in the context of an empty function body, which contains no statements or computations. This means that when such a function is called, no action or computation will take place. Additionally, curly braces `{}` in Kotlin are used to denote a block of code, which can contain zero or more statements. However, when it comes to the concept of nothing, the block would contain no statements, implying that the function does not return any value or perform any action.">Nothing</a> in more detail in the next topic, but you can read it <a href="https://hyperskill.org/learn/step/39052" rel="noopener noreferrer nofollow" target="_blank">here.</a></p>
<h5 id="conclusion">Conclusion</h5>
<p>Everything we got to know from this topic can be summarized as a neat type system tree:</p>
<p style="text-align: center;"><picture><img alt="type system trees" height="561" src="https://ucarecdn.com/d365efa2-c7bb-42cc-82ca-9be2ea2e6e90/" width="745"/></picture></p>
<p>Hopefully, now you feel at ease with Kotlin type system and can describe the relationships between the components in your programs. Remember: the type system in Kotlin is an important part of the language that can help you a lot in solving your problems.</p>
</div>