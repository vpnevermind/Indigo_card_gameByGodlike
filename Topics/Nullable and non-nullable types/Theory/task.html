<div class="step-text">
<p>If you're familiar with Java, you've probably heard something like <strong>NullPointerException </strong>(<strong>NPE</strong>). If you are reading about it for the first time, you're a lucky person because <strong>NPE </strong>is the most frequent exception, which will make you so unhappy. Moreover, there isn't any convenient way to prevent such an exception in Java. Lucky you, Kotlin has a real remedy for <strong>NPE</strong>. Though first, we need to learn about a special type of reference.</p>
<h5 id="nullability">Nullability</h5>
<p>There are just a few ways how <strong>NPE</strong> may occur in Kotlin:</p>
<ol><li><p>explicit call of <code class="language-kotlin">throw NullPointerException()</code> ;</p></li><li><p><code class="language-kotlin">!!</code> syntax;</p></li><li><p>bad <a class="theory-lookup not-relevant" href="/learn/step/7613" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, initialization refers to the process of creating and allocating memory to an object. | Lazy initialization is a technique that allows the creation of an object to be delayed until it is actually needed, rather than at the time of declaration. This is particularly useful for more complex classes, as it saves time and resources by not immediately allocating memory to objects that may not be required from the outset. By allowing objects to be initialized when they're needed, the allocation of resources can be redistributed over the life cycle of a program, leading to time savings. This can be achieved in different ways in different languages and frameworks.">initializations</a>, such as constructors and superclass constructors.</p></li></ol>
<p>If you don't know anything about these things, it's just fine. You will learn about them later. For now, just remember that you don't have to pay as much attention to <strong>NPE </strong>as in Java and that you can concentrate on real tasks. Don't forget that Kotlin is a pragmatic language. So, what do we have?</p>
<p>First of all, every reference in Kotlin can be either nullable or not. Let's say we want to define a String variable, but we are not sure what it might be initially:</p>
<pre><code class="language-kotlin">var name: String = null</code></pre>
<p>So, what is <code class="language-kotlin">null</code> above? It just means that the <code class="language-kotlin">name</code> variable doesn't have a certain value. This code won't compile because we declared a non-null variable. How can we fix it? Pretty easy:</p>
<pre><code class="language-kotlin">var name: String? = null</code></pre>
<p>As you can see, we just added a <code class="language-kotlin">?</code> sign right after the type of our variable. We marked our <code class="language-kotlin">name</code> variable as nullable. We can also do the same with other types, like <code class="language-kotlin">Int</code> or <code class="language-kotlin">Long</code>:</p>
<pre><code class="language-kotlin">var age: Int? = null</code></pre>
<p>So, without a <code class="language-kotlin">?</code> sign in the type you can't assign <code class="language-kotlin">null</code> to a variable.</p>
<h5 id="accessing-nullable-variables">Accessing nullable variables</h5>
<p>Now try to guess what happens if you try to access this variable property:</p>
<pre><code class="language-kotlin">var name: String? = null
print(name.length)</code></pre>
<p>If you think there will be an error, you're right! This code won't even compile. What can we do, then? Of course, we can add a common check for <code class="language-kotlin">null</code> like this:</p>
<pre><code class="language-kotlin">if (name != null) {
    print(name.length)
}</code></pre>
<p>If the <code class="language-kotlin">name</code> is null, the <code class="language-kotlin">print</code> won't be called.</p>
<p>Or we can access the length this way:</p>
<pre><code class="language-kotlin">print(name?.length)</code></pre>
<p>Here <code class="language-kotlin">null</code> is printed.</p>
<p>This <code class="language-kotlin">?.</code> pair of symbols is called a <strong><a class="theory-lookup not-relevant" href="/learn/step/7613" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a safe call is a way to call a member function or property accessor on an object that may be null, without causing a NullPointerException. | It is denoted by the `?.` syntax, which means if the object is not null, call the member function or access the property; otherwise, return null. This allows for more concise and safer code, especially when dealing with potentially null objects. It is particularly useful in situations where the object being called on may not always be initialized or may be null due to asynchronous operations or data fetching.">safe call</a></strong> in Kotlin. We will dig into this concept in a special topic. Right now, there is enough information for you to practice.</p>
<h5 id="billion-dollar-mistake">Billion-dollar mistake</h5>
<p>So, Kotlin introduces <a class="theory-lookup not-relevant" href="/learn/step/7613" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a nullable type is a variable that can hold a null value, in contrast to a non-nullable type, which cannot. | This is a key feature of Kotlin's null safety, which aims to eliminate null reference errors. In Kotlin, types are non-nullable by default, and if you want to declare a variable that can hold a null value, you must append a question mark to the type. When working with nullable types, Kotlin requires you to handle the possibility of a null value explicitly, making your code safer and more predictable.">nullable types</a> that differ from <a class="theory-lookup not-relevant" href="/learn/step/7613" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a non-nullable is a type that cannot hold a null value. | Unlike Java, where all reference types can hold null values, Kotlin makes a distinction between nullable and non-nullable types. By making types non-nullable by default and providing explicit nullable types, Kotlin compels developers to handle the possibility of null values in a controlled way. This helps to reduce the risk associated with null references, often referred to as the billion-dollar mistake. Safe call and the elvis operator are two features in Kotlin that help handle nullable types securely and prevent null pointer exceptions. Safe call allows you to access properties and methods of a nullable object without the risk of a null pointer exception.">non-nullable</a> ones. In old languages like Java, there is no difference because every type is nullable. Therefore, in many languages, it's not required to check a nullable variable against <code class="language-kotlin">null</code> before accessing it. This can cause lots of program crashes, and in 2009, Tony Hoare, a British Computer Scientist who invented the concept of <code class="language-kotlin">null</code> reference, described it as a "<strong><a class="theory-lookup not-relevant" href="/learn/step/7613" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a billion-dollar mistake refers to the invention of the null reference, which was introduced in 1965 by British computer scientist Tony Hoare. | This mistake caused a billion dollars of pain and damage in the last forty years. In Kotlin, there is a distinction between nullable and non-nullable types, which is different from older languages like Java where every type is nullable. This distinction helps prevent program crashes caused by not checking nullable variables before accessing them.">billion-dollar mistake</a></strong>":</p>
<p> </p>
<p>I call it my billion-dollar mistake. It was the invention of the null reference in 1965. At that time, I was designing the first comprehensive type system for references in an object-oriented language (<a href="https://en.wikipedia.org/wiki/ALGOL_W" rel="noopener noreferrer nofollow" target="_blank">ALGOL W</a>). My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn't resist the temptation to put in a <a class="theory-lookup not-relevant" href="/learn/step/7613" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a null reference refers to the concept of a variable that does not refer to any object or value. | It is a type of reference that can be assigned a null value, indicating the absence of a value. This is different from non-null references, which are always guaranteed to refer to an object or value. The introduction of null references in programming languages has been described as a billion-dollar mistake due to the numerous errors and vulnerabilities it has caused. In languages like Java, every type is nullable, which means that null checks are often not required and can lead to program crashes. In Kotlin, nullable types are distinguished from non-nullable types, and the language provides null safety features such as the safe call syntax, which allows for more concise and safer code when dealing with potentially null objects.">null reference</a> simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.</p>
<p> </p>
<h5 id="conclusion">Conclusion</h5>
<p>There are two different types of references in Kotlin. Obviously, with non-null types you don't have to pay as much attention as with nullable ones. Be careful with your references and try to define a type that is appropriate in that particular case. However, don't worry too much for in most situations the compiler will point at your mistakes.</p>
</div>